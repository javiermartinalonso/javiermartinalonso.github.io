GESTION APLICACIONES
/actuator/env
/actuator/health
/actuator/swagger-resources



# vemos los namespaces dentro del kubernates donde estan desplegados los pods

	kubectl get ingress -A
	
	NAMESPACE    NAME                                        CLASS    HOSTS                                                          ADDRESS                                                         PORTS     AGE
	argocd       argocd-server-ingress                       nginx    argocd.async.alvatest.net                                      asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   42d
	components   gateway-gateway                             nginx    oryx.async.alvatest.net                                        asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   23d
	components   product-leanrepo                            nginx    oryx.async.alvatest.net                                        asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   34d
	default      castlemock                                  <none>   castlemock.async.alvatest.net                                  asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   34d
	default      http                                        <none>   akhq.async.alvatest.net                                        asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   31d
	default      order-config-planner                        <none>   order-config-planner.async.alvatest.net                        asyncapi-k8s-nlb-7d8c5c5f47f08960.elb.eu-west-3.amazonaws.com   80, 443   31d


# ver los pods desplegados en un namespace

	kubectl get pods -n components
	
# ver los yaml de un namespace, por ejemplo para ver el path al que ataco, que servicio tiene asociado:

	 kubectl get ingress gateway-gateway -n components -o yaml
	 
	 
	 busco algo como esto:
		  - host: oryx.async.alvatest.net
			http:
			  paths:
			  - backend:
				  service:
					name: gateway-gateway
					port:
					  number: 8080
				path: /gateway-eventmanagement/
				pathType: Prefix
		
	ahora se que el servicio o nombre de pod asociado al path:  "/gateway-eventmanagement/" es:  "gateway-gateway"	
	
	
# aseguramos que el nombre del servicio es ese:
	kubectl get services gateway-gateway -n components -o yaml
	
	kubectl get deployments -n components
	
	
	
	
	









http://inventory-mediator.lab36.int.satec.es/

echo -n Enero2020 | docker login -u javier.martin --password-stdin registry.int.satec.es/app/albatross



https://kubernetes.io/docs/tutorials/hello-minikube/

### obtener version de cliente kubernates ###

kubectl version

### Veamos los detalles del clúster ###

kubectl cluster-info

### ver los nodos en el clúster ###

kubectl get nodes


kubectl get all


kubectl get ns


# sirve tanto para crear, modificar objects creados
kubectl apply -f bonita-service.yaml, bonita-deployment.yaml, bonita-secret.yaml


#ver los logs
kubectl logs -f hello-node-5f76cf6ccf-br9b5

#ver los logs de todas las replicas de un mismo servicio
kubectl logs -f -lapp=order-executor-planner
stern -lapp kafka-watchdog --tail 1

# ver los logs cuando indica error: a container name must be specified for pod

[root@node1 ~]# k logs -f customer-order-management-tmf622-product-ordering-api-5848qvrfn
error: a container name must be specified for pod customer-order-management-tmf622-product-ordering-api-5848qvrfn, choose one of: [tmf622-product-ordering-api traffic-agent]
[root@node1 ~]# k logs -f customer-order-management-tmf622-product-ordering-api-5848qvrfn -c tmf622-product-ordering-api




k logs -f customer-order-management-tmf622-product-ordering-api-5848qvrfn -c tmf622-product-ordering-api


### Eliminar los objetos definidos en dos archivos de configuración ###

kubectl delete -f nginx.yaml -f redis.yaml

### Actualice los objetos definidos en un archivo de configuración sobrescribiendo la configuración en vivo ###

kubectl replace -f nginx.yaml



## entrar en el contendor
kubectl exec -it nombre_pod sh

######################################################################
## reiniciar un pod


kubectl rollout restart deployment bonita-7-10






kubectl delete pod <nombre_pod>
kubectl delete pod bonita-f6b599554-n58gr


o bien

kubectl delete -f <fichero_deployment>
kubectl create -f <fichero_deployment>
######################################################################







### Ejecute una instancia del contenedor nginx creando un objeto de implementación ###

kubectl run nginx --image nginx



###Cree los objetos definidos en un archivo de configuración ###

kubectl create -f nginx.yaml


Create an object from a yaml definition file with 

kubectl create -f my-pod.yml


After an object is created, alter it by changing the yaml file and using 
kubectl apply -f my-pod.yml

Editing objects directly is possible, with 
kubectl edit $object_type $object_name




### Use el kubectl comando ```create``` para crear una implementación que administre un Pod. 
El Pod ejecuta un Contenedor basado en la imagen Docker proporcionada ###

kubectl create deployment hello-node --image=gcr.io/hello-minikube-zero-install/hello-node
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080



### crear un proxy para poder ver o atacar mediante un puerto abierto a un nodo desde fuera del nodo kubernates ###

Los pods que se ejecutan dentro de Kubernetes se ejecutan en una red privada y aislada. 
De forma predeterminada, son visibles desde otros pods y servicios dentro del mismo clúster de kubernetes, 
pero no fuera de esa red. Cuando usamos kubectl, estamos interactuando 
a través de un punto final API para comunicarnos con nuestra aplicación.

El comando kubectl puede crear un proxy que reenviará las comunicaciones a la red privada de todo el clúster. 
El proxy se puede terminar presionando control-C y no mostrará ningún resultado mientras se está ejecutando.

echo -e "\n\n\n\e[92mStarting Proxy. After starting it will not output a response. Please click the first Terminal Tab\n"; 
kubectl proxy


### obtener el pod name ###

export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Name of the Pod: $POD_NAME

### obtener el nodo port ###
export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
echo NODE_PORT=$NODE_PORT

### consulta usando labels, ver el pod que está ejecutando con la siguiente etiqueta ###
kubectl get pods -l run=kubernetes-bootcamp



### eliminar servicio que cumple con el siguiente criterio ###

kubectl delete service -l run=kubernetes-bootcamp

To see the ReplicaSet created by the Deployment, run 

kubectl get rs


Next, let’s scale the Deployment to 4 replicas. We’ll use the kubectl scale command, followed by the deployment type, name and desired number of instances:

kubectl scale deployments/kubernetes-bootcamp --replicas=4

kubectl get pods -o wide

There are 4 Pods now, with different IP addresses. The change was registered in the Deployment events log. To check that, use the describe command:

kubectl describe deployments/kubernetes-bootcamp

You can also view in the output of this command that there are 4 replicas now.



## Step 1: Update the version of the app ##

To view the current image version of the app, run a describe command against the Pods (look at the Image field):

kubectl describe pods

### To update the image of the application to version 2 ###, use the set image command, followed by the deployment name and the new image version:

kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2

The command notified the Deployment to use a different image for your app and initiated a rolling update. Check the status of the new Pods, and view the old one terminating with the get pods command:

kubectl get pods


Let’s perform another update, and deploy image tagged as v10 :

kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10


There is no image called v10 in the repository. Let’s roll back to our previously working version. We’ll use the rollout undo command:

kubectl rollout undo deployments/kubernetes-bootcamp










### Let’s list the environment variables ###

$ kubectl exec $POD_NAME env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=kubernetes-bootcamp-5b48cfdcbd-6h8fl
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_PORT=443
NPM_CONFIG_LOGLEVEL=info
NODE_VERSION=6.3.1
HOME=/root



kubectl get - list resources
kubectl describe - show detailed information about a resource
kubectl logs - print the logs from a container in a pod
kubectl exec - execute a command on a container in a pod





ClusterIP (predeterminado): expone el servicio en una IP interna en el clúster. Este tipo hace que solo se pueda acceder al Servicio desde el clúster.
NodePort : expone el servicio en el mismo puerto de cada nodo seleccionado en el clúster utilizando NAT. Hace que un servicio sea accesible desde fuera del clúster mediante <NodeIP>:<NodePort>. Superconjunto de ClusterIP.
LoadBalancer : crea un equilibrador de carga externo en la nube actual (si es compatible) y asigna una IP externa fija al Servicio. Superconjunto de NodePort.
ExternalName : expone el Servicio utilizando un nombre arbitrario (especificado externalNameen la especificación) al devolver un registro CNAME con el nombre. No se usa proxy. Este tipo requiere v1.7 o superior de kube-dns.









### Eliminar los objetos definidos en dos archivos de configuración ###

kubectl delete -f nginx.yaml -f redis.yaml

### Actualice los objetos definidos en un archivo de configuración sobrescribiendo la configuración en vivo ###

kubectl replace -f nginx.yaml



### Ver la lista de implementaciones de aplicaciones, instancias de aplicaciones corriendo en los nodos ###

kubectl get deployments

La salida es similar a:

NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m


### Ver el pod ###

kubectl get pods
La salida es similar a:

NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m

ver los logs
kubectl logs -f hello-node-5f76cf6ccf-br9b5


### Ver eventos de clúster ###

kubectl get events

### Ver la configuración kubectl ###

kubectl config view

### Crear un servicio ###

De forma predeterminada, solo se puede acceder al Pod por su dirección IP interna dentro del clúster de Kubernetes. Para que el hello-nodeContenedor sea accesible desde fuera de la red virtual de Kubernetes, debe exponer el Pod como un Servicio de Kubernetes .

Exponga el Pod a Internet público con el kubectl exposecomando:

kubectl expose deployment hello-node --type=LoadBalancer --port=8080

El indicador '''--type=LoadBalancer''' indica que desea exponer su Servicio fuera del clúster.

### Ver el servicio que acaba de crear ###

kubectl get services

La salida es similar a:

NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-node   LoadBalancer   10.108.144.78   <pending>     8080:30369/TCP   21s
kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP          23m



------------------------------------------------------------------------------------------------------------------------
### Ver espacios de nombre ###

Puedes listar los espacios de nombres actuales dentro de un clúster mediante:

kubectl get namespaces

NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d

Kubernetes arranca con tres espacios de nombres inicialmente:

default El espacio de nombres por defecto para aquellos objetos que no especifican ningún espacio de nombres
kube-system El espacio de nombres para aquellos objetos creados por el sistema de Kubernetes
kube-public Este espacio de nombres se crea de forma automática y es legible por todos los usuarios (incluyendo aquellos no autenticados). Este espacio de nombres se reserva principalmente para uso interno del clúster, en caso de que algunos recursos necesiten ser visibles y legibles de forma pública para todo el clúster. La naturaleza pública de este espacio de nombres es simplemente por convención, no es un requisito.
Establecer el espacio de nombres para una pe




------------------------------------------------------------------------------------------------------------------------

https://kubernetes.io/es/docs/concepts/overview/working-with-objects/common-labels/

------------------------------------------------------------------------------------------------------------------------


https://kubernetes.io/docs/tutorials/hello-minikube/




Habilitar complementos
Minikube tiene un conjunto de complementos integrados que se puede habilitar, deshabilitar y abrir en el entorno local de Kubernetes.

Enumere los complementos actualmente compatibles:

minikube addons list
La salida es similar a:

addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
Habilite un complemento, por ejemplo metrics-server:

minikube addons enable metrics-server
La salida es similar a:

metrics-server was successfully enabled
Vea el Pod y el Servicio que acaba de crear:

kubectl get pod,svc -n kube-system
La salida es similar a:

NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    <none>        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      <none>        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     <none>        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   <none>        8083/TCP,8086/TCP   26s
Deshabilitar metrics-server:

minikube addons disable metrics-server
La salida es similar a:

metrics-server was successfully disabled
Limpiar
Ahora puede limpiar los recursos que creó en su clúster:

kubectl delete service hello-node
kubectl delete deployment hello-node
Opcionalmente, detenga la máquina virtual Minikube (VM):

minikube stop
Opcionalmente, elimine la VM Minikube:

minikube delete

